* [浅谈AJAX](https://github.com/Meng823/Blog/blob/master/md/ajax.md)
<br>

* 同源策略：浏览器最核心也最基本的安全功能，同源就是域名，协议名，端口号都相同；<br>
如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问
<br>

* 浏览器访问一个URL的过程
    * 首先浏览器会检查这个URL是否访问过，即存不存在DNS缓存，若不存在，则向网站的DNS服务器发起请求，当网站的DNS解析器解析完成后，将请求指向CDN网络中的智能DNS负载均衡系统，当系统解析域名之后，将对用户反应速度最快的IP节点返回给用户
    * 浏览器通过TCP协议建立到服务器的连接（三次握手）
    * 浏览器向服务器发送HTTP请求包，请求服务器中的文档资源
    * 服务器返回给浏览器HTTP应答包，发送完成后，通过四次挥手断开连接
    * 客户端解析应答包，处理HTML文档
<br>

* 浏览器的渲染机制（接上问题）
    * 首先浏览器请求到HTML文档后，在生成DOM的最开始阶段，并行发起css，image，js的请求
    * 第二步，将CSS文件下载完成后，开始构建CSSOM
    * 在所有CSS文件下载完成之后，CSS构建结束，与DOM树一起生成Render Tree
    * 下一步Layout，通过Render Tree，得到各个节点的CSS及从属关系，计算出每个节点在屏幕中位置
    * 最后Painting，根据Layout，将计算出来的位置，将内容画到屏幕上

* 性能优化的几种方式
    * 代码级优化
        * 接上一个问题，Painting是非常消耗性能的，所以需要减少重绘(repaint)和重排(reflow)<br>
        重绘是元素自身的位置和宽高不变，只改变颜色等属性，不会导致其他元素位置发生变化时发生的事件<br>
        重排是自身位置发生变化，或宽高改变导致其他元素位置发生移动时发生的事件；重绘不一定重排，重排一定重绘
        * 减少DOM操作：DOM操作非常消耗性能，因为进行DOM操作，每次都要遍历DOM树，直至找到才停止
        * 减少使用with：with可延长作用域链，导致查询性能下降
        * 减少使用构造函数：每次使用Function构造函数，都会讲构造函数中的代码重新执行一遍，而且还涉及到一个this指向的问题；直接调用Function的话会快几倍以上
        * 避免使用eval：eval()会先检查其中字符串是不是可执行代码，若是可执行代码，则转换后执行
    * 页面级优化（减少HTTP请求数是最有效的方法）
        * 将页面设计的尽量简洁，可从各个方面减少HTTP请求数
        * 合理设置HTTP缓存：设置恰当的缓存，可大大减少HTTP请求，并设置较长时间的Expires，可作为`预加载`使用
        * 精灵图，将icon放到一个图片资源中，谈后通过改变位置来获取需要的图片，这样合并CSS图片可大幅度减少HTTP请求
        * 懒加载：只将屏幕可视区域的图片资源，当向后滚屏的时候才加载后面的资源（瀑布流是其中的一种应用）<br>
        将页面中所有的img的src属性用data-xx代替，当图片出现在可视区域时，用js将data-xx的值赋给src
        * 避免请求重复的资源：不同模块可能用到同一资源，重复请求时没有必要的
        * 资源合并与压缩：压缩后不光可以节省空间，还能使下载/加载速度变快很多
<br>


* 常用跨域方式
    * [jsonp](https://github.com/Meng823/Test-Blog/blob/master/md/jsonp.md)：
    由于script的src属性不受同源策略影响。可以把资源直接放到src中，以json的形式把数据放到了服务器上 
    * document.domain + iframe：只有在主域相同而子域不同的情况下这种方式才可以使用。
    * window.name + iframe：主页面有一个iframe，通过修改子页面的window.name让主页面获取到这个值。
    * localtion.hash + iframe：通过location.hash来设置，通过hash值来进行数据传递，注：hash值在url中，有长度的限制
    * postMessage:H5的接口，可以传两个参数，第一个是要传递的消息，第二个是url，但是在worker里比较特殊，只有一个参数
    * WebSocket API：它允许代码在客户端和支持WebSocket协议的服务器创建双向套接字的连接。支持传递文本消息，必须以UTF-8编码的字符串传递给该消息，完成和服务器通信后，使用close()方法来关闭
    * Flash：不仅是一个动画，它有很多数据交互，会通过自身的安全机制进行跨域。但是不便于管理和维护，现在基本已经废弃
    * CORS：XHR2中出现的方法，允许浏览器向跨源服务器，发出XMLHttpRequest请求，克服了AJAX只能同源使用的限制。<br>
    CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，会自动添加一些附加的头信息(Origin字段)，有时会多出一次附加的请求，但用户不会有感觉。因此，只要服务器实现了CORS接口，就可以跨源通信。
    <br>

* 浏览器的缓存机制
    * 用户在第一次上一个网页之后，浏览器会把一些需要请求的资源放到缓存里面，后面再次登录这个网页就会先去询问服务器自己有没有缓存。如果缓存过了，那么浏览器会再次询问服务器缓存的资源有没有被修改过，如果没有修改，那么直接从缓存拿过来，否则就重新获取。
    * 缓存时间设置：expires设置的是绝对时间，在没过这个时间之前访问服务器，则直接在缓存中获取，但是由于客户端时间可以被修改，所以后来出现了cache-control<br>
    cache-control:max-age设置的是相对时间，可以理解为一个倒计时，倒计时没结束前，都会在缓存中直接获取资源
    * last-modified：客户端第一次访问一个资源时，服务器会返回一个last-modified（绝对时间），浏览器获取到这个缓存时，会同时记录这个最后修改时间<br>
    第二次访问这个资源时，若没设置expires或cache-control，则访问资源时会带上If-Modify-since，服务器通过对比，若没有修改，则返回304，若有修改，则返回200并带上资源
    * e-tage：第一次访问资源时，服务器返回资源时，同时返回一个e-tag，e-tag中保存着一个标签，如果修改过，标签就会改变<br>
    第二次访问这个资源时，由于缓存中已经有e-tag，客户端向浏览器发送if-not-Match，告诉服务器我这边的资源标签是什么，如果一样，则返回304，不需要返回内容，服务器通过比较标签，看返回304还是200<br>
    ETag实际上很少使用，因为它的计算是通过算法得出的，而算法会占用服务端计算的资源，影响服务器性能
<br>

* cookie相关知识点
    * cookie是由服务器生成的，发送给浏览器，浏览器会通过cookieEnable设置cookie，若为true，则会将cookie以key/value的形式保存在某个目录的文本文件内，下次请求同一网站时就发送cookie给服务器；如果设置为false，则cookie的有效期与整个浏览器进程一致，可用max-age延长cookie有效期
    * 由于http是无状态协议，但是在web应用中，实际上要记住每次请求，cookie和session的作用就是让服务器知道不同请求是否来自同一个客户端，下面简述一下cookie和session的区别
        * cookie将数据存放在客户端上，session存放在服务端上
        * 由于cookie在客户端，所以黑客或不良网站可获取并分析客户端cookie，进行cookie欺骗，服务端的session更安全
        * session由于在服务器端，访问增多，会影响服务器端性能，所以将登陆信息等重要信息放在session中，其他信息放到cookie中
        * cookie采用的是客户端保持状态的方案，session是一种在客户端与服务端之间保持状态的解决方案
    * cookie的特点：1.有生命周期　2.满足同源策略　3.内存大小受到限制(4k左右)
    * cookie的内容主要包括：名字，值，过期时间，路径，域。路径和域一起构成cookie的作用范围    
