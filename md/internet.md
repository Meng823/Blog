* HTTP和HTTPS的基本概念
    * HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
    * HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
<br>

* HTTP1.0和HTTP1.1的区别
    * HTTP1.0定义了三种方法：GET,POST,HEAD
    * HTTP1.1新增了五种请求方法：PUT,DELETE,CONNET,OPTIONS,TRACE
<br>

* 长连接、短连接与长轮询、短轮询
    * HTTP协议基于请求/响应模式，所以只要服务器给了响应HTTP连接就认为结束了，不涉及长短连接<br>
    HTTP实际上是应用层协议，TCP才是传输层协议，传输层协议才用建立连接
    * 长短连接本质上说的是TCP连接，TCP连接是一个双向通道，可保持一段时间不关闭。
    * 长连接优点：为了复用，多个HTTP请求复用一个TCP连接，节省了TCP的简历和断开的消耗

<br>

* get和post区别
    * “标准答案”
        * 可见性：GET提交数据，在URL中可见。POST传递数据，参数在URL中不可见
        * 数据量：GET请求提交的数据长度限制一般是255个字符，POST请求没有限制。<br>
        注：字符长度限制是由浏览器和服务器规定的,GET并没有规定
        * 数据缓存：GET请求参数会保留在浏览器历史记录里，而POST中的参数不会被保留。 
        * 数据类型：GET只接受文本，而POST为文本或二进制数据
        * 资源类型：没有副作用（如搜索）使用GET（主动或被动）；有副作用时（如添加数据行）使用POST（主动）
    * 技术上来讲没有区别
        * GET和POST是HTTP协议中的两种发送请求的方法，从底层来看GET/POST都是TCP链接。
        * HTTP没有规定说GET的参数一定要写在URL中，POST的参数一定要在body里，所以，从技术层面上，来说没有区别
    * 转折！实际使用上的区别
        * GET产生一个TCP数据包;POST产生两个TCP数据包。
        * 对于GET请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据)
        * 对于POST请求，浏览器先发送header，服务器响应100 ，浏览器再发送data，服务器响应200(返回数据)。
    * 虽然从技术层面上来讲没有区别，但最好不要选择混用
        *  在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
        * 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次
    * 安全性问题
        * 表层：POST比GET安全，因为GET的数据在URL中可见，容易被黑客截获<br>
        实际上，现在SSL编码还是比较复杂的，进行加密后不太容易破解,虽然GET方法不会改变服务器端数据，但是黑客可用账号密码登录个人账号获取个人信息
        * 深层：利用web封包截取，可以发现两者安全性都是一样的，都可轻易被获取
<br>

* [浅谈AJAX](https://github.com/Meng823/Blog/blob/master/md/ajax.md)
<br>

* 同源策略：浏览器最核心也最基本的安全功能，同源就是域名，协议名，端口号都相同；<br>
如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问
<br>

* 浏览器访问一个URL的过程
    * 首先浏览器会检查这个URL是否访问过，即存不存在DNS缓存，若不存在，则向网站的DNS服务器发起请求，当网站的DNS解析器解析完成后，将请求指向CDN网络中的智能DNS负载均衡系统，当系统解析域名之后，将对用户反应速度最快的IP节点返回给用户
    * 浏览器通过TCP协议建立到服务器的连接（三次握手）
    * 浏览器向服务器发送HTTP请求包，请求服务器中的文档资源
    * 服务器返回给浏览器HTTP应答包，发送完成后，通过四次挥手断开连接
    * 客户端解析应答包，处理HTML文档
<br>

* 浏览器的渲染机制（接上问题）
    * 首先浏览器请求到HTML文档后，在生成DOM的最开始阶段，并行发起css，image，js的请求
    * 第二步，将CSS文件下载完成后，开始构建CSSOM
    * 在所有CSS文件下载完成之后，CSS构建结束，与DOM树一起生成Render Tree
    * 下一步Layout，通过Render Tree，得到各个节点的CSS及从属关系，计算出每个节点在屏幕中位置
    * 最后Painting，根据Layout，将计算出来的位置，将内容画到屏幕上

* 性能优化的几种方式
    * 代码级优化
        * 接上一个问题，Painting是非常消耗性能的，所以需要减少重绘(repaint)和重排(reflow)<br>
        重绘是元素自身的位置和宽高不变，只改变颜色等属性，不会导致其他元素位置发生变化时发生的事件<br>
        重排是自身位置发生变化，或宽高改变导致其他元素位置发生移动时发生的事件；重绘不一定重排，重排一定重绘
        * 减少DOM操作：DOM操作非常消耗性能，因为进行DOM操作，每次都要遍历DOM树，直至找到才停止
        * 减少使用with：with可延长作用域链，导致查询性能下降
        * 减少使用构造函数：每次使用Function构造函数，都会讲构造函数中的代码重新执行一遍，而且还涉及到一个this指向的问题；直接调用Function的话会快几倍以上
        * 避免使用eval：eval()会先检查其中字符串是不是可执行代码，若是可执行代码，则转换后执行
    * 页面级优化（减少HTTP请求数是最有效的方法）
        * 将页面设计的尽量简洁，可从各个方面减少HTTP请求数
        * 合理设置HTTP缓存：设置恰当的缓存，可大大减少HTTP请求，并设置较长时间的Expires，可作为`预加载`使用
        * 精灵图，将icon放到一个图片资源中，谈后通过改变位置来获取需要的图片，这样合并CSS图片可大幅度减少HTTP请求
        * 懒加载：只将屏幕可视区域的图片资源，当向后滚屏的时候才加载后面的资源（瀑布流是其中的一种应用）<br>
        将页面中所有的img的src属性用data-xx代替，当图片出现在可视区域时，用js将data-xx的值赋给src
        * 避免请求重复的资源：不同模块可能用到同一资源，重复请求时没有必要的
        * 资源合并与压缩：压缩后不光可以节省空间，还能使下载/加载速度变快很多
<br>


* 常用跨域方式
    * [jsonp](https://github.com/Meng823/Test-Blog/blob/master/md/jsonp.md)：
    由于script的src属性不受同源策略影响。可以把资源直接放到src中，以json的形式把数据放到了服务器上 
    * document.domain + iframe：只有在主域相同而子域不同的情况下这种方式才可以使用。
    * window.name + iframe：主页面有一个iframe，通过修改子页面的window.name让主页面获取到这个值。
    * localtion.hash + iframe：通过location.hash来设置，通过hash值来进行数据传递，注：hash值在url中，有长度的限制
    * postMessage:H5的接口，可以传两个参数，第一个是要传递的消息，第二个是url，但是在worker里比较特殊，只有一个参数
    * WebSocket API：它允许代码在客户端和支持WebSocket协议的服务器创建双向套接字的连接。支持传递文本消息，必须以UTF-8编码的字符串传递给该消息，完成和服务器通信后，使用close()方法来关闭
    * Flash：不仅是一个动画，它有很多数据交互，会通过自身的安全机制进行跨域。但是不便于管理和维护，现在基本已经废弃
    * CORS：XHR2中出现的方法，允许浏览器向跨源服务器，发出XMLHttpRequest请求，克服了AJAX只能同源使用的限制。<br>
    CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，会自动添加一些附加的头信息(Origin字段)，有时会多出一次附加的请求，但用户不会有感觉。因此，只要服务器实现了CORS接口，就可以跨源通信。
    <br>

* 浏览器的缓存机制
    * 用户在第一次上一个网页之后，浏览器会把一些需要请求的资源放到缓存里面，后面再次登录这个网页就会先去询问服务器自己有没有缓存。如果缓存过了，那么浏览器会再次询问服务器缓存的资源有没有被修改过，如果没有修改，那么直接从缓存拿过来，否则就重新获取。
    * 缓存时间设置：expires设置的是绝对时间，在没过这个时间之前访问服务器，则直接在缓存中获取，但是由于客户端时间可以被修改，所以后来出现了cache-control<br>
    cache-control:max-age设置的是相对时间，可以理解为一个倒计时，倒计时没结束前，都会在缓存中直接获取资源
    * last-modified：客户端第一次访问一个资源时，服务器会返回一个last-modified（绝对时间），浏览器获取到这个缓存时，会同时记录这个最后修改时间<br>
    第二次访问这个资源时，若没设置expires或cache-control，则访问资源时会带上If-Modify-since，服务器通过对比，若没有修改，则返回304，若有修改，则返回200并带上资源
    * e-tage：第一次访问资源时，服务器返回资源时，同时返回一个e-tag，e-tag中保存着一个标签，如果修改过，标签就会改变<br>
    第二次访问这个资源时，由于缓存中已经有e-tag，客户端向浏览器发送if-not-Match，告诉服务器我这边的资源标签是什么，如果一样，则返回304，不需要返回内容，服务器通过比较标签，看返回304还是200<br>
    ETag实际上很少使用，因为它的计算是通过算法得出的，而算法会占用服务端计算的资源，影响服务器性能
<br>

* cookie相关知识点
    * cookie是由服务器生成的，发送给浏览器，浏览器会通过cookieEnable设置cookie，若为true，则会将cookie以key/value的形式保存在某个目录的文本文件内，下次请求同一网站时就发送cookie给服务器；如果设置为false，则cookie的有效期与整个浏览器进程一致，可用max-age延长cookie有效期
    * cookie每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
    * 由于http是无状态协议，但是在web应用中，实际上要记住每次请求，cookie和session的作用就是让服务器知道不同请求是否来自同一个客户端，下面简述一下cookie和session的区别
        * cookie将数据存放在客户端上，session存放在服务端上
        * 由于cookie在客户端，所以黑客或不良网站可获取并分析客户端cookie，进行cookie欺骗，服务端的session更安全
        * session由于在服务器端，访问增多，会影响服务器端性能，所以将登陆信息等重要信息放在session中，其他信息放到cookie中
        * cookie采用的是客户端保持状态的方案，session是一种在客户端与服务端之间保持状态的解决方案
    * cookie的特点：1.有生命周期　2.满足同源策略　3.内存大小受到限制(4k左右)
    * cookie的内容主要包括：名字，值，过期时间，路径，域。路径和域一起构成cookie的作用范围    

* H5中的两种存储方式sessionStorage和localstorage的异同
    * 两者储存数据量的大小一般为5MB左右，cookie在4k左右
    * 两者都是在客户端（即浏览器）中保存，不参与和服务器的通信
    * sessionStorage：可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage中的数据就会被销毁。作用域：顶级窗口
    * localstorage：持久化本地数据，保存在客户端的某个文档源中，除非主动删除，否则永不过期
    * 操作方法：setItem(key,value),getItem(key),removeItem(key),clear();
