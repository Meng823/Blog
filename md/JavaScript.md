* js数据类型
    * 五种基本类型：Number，String，Boolean，null，undefined；复杂数据类型：Object
    * 原始类型：Number，String，Boolean；特殊类型：null，undefined；
    * 值类型与引用类型：
        * 值类型(Number，Boolean，null，undefined)：把值传递给另一个变量（赋值），相当于分配了一块新的内存空间
        * 引用类型(Object,Array,Function)：相当于让指针指向另一变量，拥有同一块内存空间
        * String类型的特殊性：因为字符串大小可变，所以不能被存储在具有固定大小的变量中。且JS只复制对字符串的引用，而不是字符串的内容。但是但字符串不可变，因此String是行为与基本类型相似的不可变引用类型<br>
    注：原始值是不可变的，任何方法都不能改变原始值内容。像 String的方法，只能返回新的字符串，而不能修改原始字符串
    <br>

* 预编译
    * 函数在执行的前一刻执行期上下文，就是Activeaction Object对象，简称AO对象。
    * 创建AO对象。
    * 寻找形参和变量声明，将变量和形参作为AO对象的属性名添加到对象中，值为undefined。
    * 将实参值和形参值相统一。
    * 在函数体里面寻找函数声明，将函数名作为属性名，值为这个函数的函数体。
    <br>

* 变量声明
    * var 最近的函数作用域；可重复定义；存在变量声明提升
    * let 仅在声明的变量所在的代码块内有效；不可重复定义；存在暂时性死区
    * const 声明一个只读的常量。一旦声明，就必须立即初始化，且值就不能改变，不能在后面赋值，也存在暂时性死区；<br>
    但const若为复合类型，则数据储存的是一个地址，不可变的只是这个地址，但对象本身是可变的，所以可为其添加新属性。<br>
<br>

* ==和===区别
    * "=="称作相等运算符，用它检测两个操作数是否相等，允许进行类型转换
    * "==="称为严格相等运算符，用它检测两个操作数是否严格相等
    * 对象和其本身是相等的，但和其他任何对象都不相等。如果两个不同对象具有相同数量的属性，属性名和值，依旧不相等
    * "==="首先计算其操作数的值，然后比较两个值，比较过程中不发生任何类型转换
        >* 两个值类型不相同，则不相等
        >* 两个值都是null或undefined，则不相等
        >* 若其中一个值或两个值为NaN，则不相等
        >* 若两个值为字符串，且所含对应位上的16位数完全相等，则相等；可能两个字符串含义完全一样，但16位编码不同，也不相等（利用fromCharCode()方法）
        >* 若两个值为数字且数值相等，则相等
        >* 若两个引用值指向同一个对象，数组或函数，则相等
    * "=="和严格等于类似，若两个操作数不是同一类型，相等运算符会尝试一些类型转换后再比较
        * 若两个操作数类型相同，则结果与严格相等结果一样
        * 若操作数类型不同，则会发生类型转换
            >* 一个值是null，一个是undefined，则相等
            >* 一个值是数字，另一个值是字符串，则先将字符串转换为数字，然后比较
            >* 一个值为布尔值，则转换为1或0再进行比较
            >* 一个值为对象，一个值为数字或字符串，则先转化为原始值，再比较
            >* 其他不同类型之间的比较均不相等
<br>

* with()和eval()的用法及其缺点
    * with语句用于临时扩展作用域链，with(object)将object添加到作用域链的头部，然后执行statment，再将作用域链恢复到初始状态
    <br>在对象嵌套很深层次，通常用with语句简化代码；
    <br>缺点：with语句非常难于优化，与没有使用with的代码相比，运行更慢
    * eval()只有一个参数，如果传入的参数不是字符串，它直接返回这个参数，如果是字符串，则会把字符串当成JS代码进行编译，如果编译失败则抛出一个语法错误，如果编译成功则开始执行这段代码，并返回字符串最后一个表达式或语句的值
    <br>缺点：需要转译为js代码，非常消耗性能，而且如果是来自网络的代码，可能会执行被篡改过的代码，造成安全隐患
    <br>

* 原型及原型链
    * 原型是function对象的一个属性，它定义了构造函数构造出的对象的公共祖先，通过构造函数产生的对象继承原型的属性及方法
    * 原型上还有原型的结构叫原型链，所有内置构造函数都集成object.prototype的原型<br>
<br>

* 描述new一个对象会发生哪些过程
    1. 创建一个新对象
    2. 将构造函数的作用域赋给新对象（this指向这个新对象）
    3. 执行构造函数中的代码（为这个对象添加属性）
    4. 返回新对象

<br>

* call，apply和bind的区别
    * 三者都可以改变this指向
    * call()：参数一个一个传递
    * apply()：参数以数组形式传递
    * bind()：参数一个一个传递，并会返回一个新函数
<br>

* 判断一个对象是不是数组
    * a instanceof Array：返回true
    * a.constructor == Array：返回true
    * Array.prototype.isPrototypeOf(arr)：返回true
    * Object.getPrototypeOf(arr)==Array.prototype：返回true
    * Object.prototype.toString.call(arr)：类属性方法判断，返回[object Array]

<br>

* 类数组转化成数组
    * Array.from(arrayLink, [mapfn],[thisArg]) 从一个类似数组或可迭代的对象中创建一个新的数组实例。第一个参数是想要转变成真实数组的类数组对象或可遍历对象，第二个参数是最后生成的数组会经过该函数的加工处理后返回。第三个参数是执行第二个参数函数时的this指向
    * Array.prototype.slice.call(arrayLink), 返回一个新数组，不改变原对象。
    * Array.prototype.splice.call(arrayLink, 0), 返回一个新数组，但是会删掉原对象的值。
<br>

* 数组及对象的方法　=>　[传送门](https://github.com/Meng823/Blog/blob/master/md/method.md)
<br>

* 继承的方式　=>　[传送门](https://github.com/Meng823/Blog/blob/master/md/inherit.md)
<br>

* 闭包与作用域
    * 作用域：变量及函数生效的区域；es5中只有函数作用域和全局作用域，es6中新增块级作用域
    * 作用域链：函数存在作用域，函数间又可以相互嵌套，因此产生作用域链
    * 闭包：在正常情况下，函数执行完会将变量销毁，但是外部的函数还保存着原本函数作用域链的引用，导致原本的函数的作用域没有被销毁，因此产生了闭包；<br>一句话概括就是：内部的函数被保存到了外部，即内部函数在作用域外被引用，就会产生闭包
    * 由于函数对象可通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，所以，从技术角度上讲，`所有的函数都是闭包`；因为他们都是对象，都关联到作用域链，且定义大多数函数时的作用域链在调用函数时依然有效
    * function fn(){};fn()：这个函数执行时就会产生一个封闭的作用域，这个封闭作用域就是闭包；
    * ;(function(){})();：这就是闭包的一种应用，这样用闭包可以避免变量冲突和污染，并且能够立即执行
    * 闭包的优缺点：
        * 优点：上面提到，可以避免变量冲突和污染
        * 缺点：1.如果闭包中有引用类型的数据在闭包外被使用，那这个闭包就无法释放，造成内存泄露
        <br>解决方法：在函数执行结束前，将不使用的局部变量删除
<br>

* in和instanceof的区别
    * in运算符，要求其左边的运算数是一个字符串，或可以被转换为字符串，右边的运算数是一个对象或数组。
    <br>如果该运算符左边的值是其右边对象的一个属性名，它返回true
    * instanceof运算符要求其左边的运算数是一个对象，右边的运算数是对象类名字。
    <br>若该运算符左边的对象是右边类的一个实例，返回true，否则false；若左边不是对象，或者右边是一个对象而不是一个构造函数，返回false；若它右边根本就不是对象，返回runtime error
<br>

* for，for/in和forEach的区别
    * for循环是对数组的元素进行循环，而不能引用于非数组对象
    * for/in语句用于对数组或者对象的属性进行循环操作。
    * forEach()是数组方法，使用括号中方法遍历数组每一位，并且不能break
<br> 

* 事件处理模型与事件委托
    * `事件冒泡`：在结构上有嵌套关系的元素，触发一事件，子元素会冒泡向父元素的同一事件，结构自底向上<br>
    取消事件冒泡方法：w3c标准：event.stopPropagation()；IE方法：event.cancelBubble();
    * `事件捕获`：在结构上有嵌套关系的元素，触发一事件，父元素会捕获向子元素的同一事件，结构自顶向下<br>
    事件捕获：w3c标准：addEventListener()/removeEventListener()；<br>
    IE方法：attachEvent('on'+type,fn)/detachEvent('on'+type,fn)
    * 当`事件冒泡`和`事件捕获`同时存在的时候，事件冒泡和事件捕获的触发顺序则为：先捕获，再冒泡。
    * `事件源对象`：触发事件冒泡的对象就是事件源对象。火狐获取事件源对象：event.target ；IE获取事件源对象：event.srcElement 
    * `事件委托`：利用事件源对象和事件冒泡处理的方式就是事件委托
    * 阻止默认事件：1.w3c标准：preventDefault()；2.return false；3.IE方法e.returnValue = false
<br>

* JavaScript异步加载的三种方案
    * 通过createlement创建script标签，插入到DOM中，加载完毕后callback
    * defer：文档与js脚本同时加载，等到DOM文档全部解析完才会被执行,缺点：速度较慢
    * async：一旦脚本可用，就立即执行，缺点：脚本的执行顺序会出现问题
    <br>1.当defer和async同时存在时，忽略defer，以async的方式调用，
    <br>2.defer和async在网络加载过程是一致，都是异步执行的；
    <br>3.defer更符合大多数场景对应用脚本加载和执行的要求；
    ![](https://github.com/Meng823/Blog/blob/master/img/script.jpg)
<br>
   
* [下一篇：网络相关知识点](https://github.com/Meng823/Blog/blob/master/md/internet.md)
<br>

...持续更新中，莫急莫慌...